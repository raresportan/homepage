---
title: Functional Style Programming
date: 2020-08-19
description: 
keywords: ['Functional programming', 'JavaScript']
---
The vast majority of the programmers use a OOP language like Ruby, Python, Java or C++. 
Very few of us has used a functional programming language like Lisp or Haskell. 

Many problems in software development are caused by programmers that don’t fully 
understanding all the possible states of their code. Especially in a multithreaded 
environment, these problems are greatly amplified, almost to the point of panic. 

Programming in a functional style makes the state presented by your code explicit, 
which makes it much easier to reason about.

Trying to understand what functional programming is about, is often off-putting. 
You soon hit a wall of impenetrable jargon and academic math references. But there 
are some ideas from functional programming that are extremely useful even for OOP programmers. 
There is real value in following e functional style of programming, but we cannot all 
abandon our favourite OOP language, everything we know, all our hard won knowledge. 

This tries to explain how you can benefit from a functional style way of programming while 
still using your favourite OOP language.

The good news is that, no matter what language you work in, programming in a functional style provides benefits. You should do it whenever it is convenient, and you should think hard about the decision when it isn’t convenient. 

## Pure Functions
One of the core ideas of functional programming is the concept of pure function. A pure function only uses the parameters passed in to it, and all it does is return one or more computed values based on the parameters. It has no side effects. It doesn’t uses global state. It doesn’t uses anything outside of it. It doesn’t maintain internal state. It doesn’t perform any IO. It doesn’t mutate any of the input parameters. 
Pure functions have a lot of nice properties:

### Thread safety.  
A pure function with value parameters is completely thread safe.  
With references or pointer parameters you do need to be aware of the danger that 
another thread doing non-pure operations might mutate the data, but it is still 
one of the most powerful tools for writing safe multithreaded code. 

You can trivially switch them out for parallel implementations, or run multiple implementations 
to compare the results. This makes it much safer to experiment and evolve.

### Reusability. 
It is much easier to move a pure function to a new environment.
There is no snowball effect. How many times have you known there was some code that 
does what you need in one place, but extricating it from all of its environmental 
assumptions was more work than just writing it over? 

### Testability.  
A pure function has referential transparency, which means that it will always give 
the same result for the same parameters no matter when it is called, which makes 
it much easier to exercise than something interwoven with other systems. 

Pure functions are trivial to test; the tests look like something right out of a textbook, 
where you build some inputs and look at the output. 
Whenever I come across a finicky looking bit of code now, I split it out into a 
separate pure function and write tests for it. Frighteningly, I often find something 
wrong in these cases.	

## Understandability and maintainability.  

Since everything is there in your face, pure functions easier to re-learn when needed, 
and there are less places for undocumented requirements regarding external state to hide.

We are a “Move fast” sort of industry and being able to prove that certain classes of 
problems are not present in certain parts of our code is very valuable. 
You might be asking “Aren’t all programs supposed to be written like this?” 
The reality is that most of the programs are Big Balls of Mud. 

Pure functions are not used by many people. Most of them don’t even know about them.
Of course, not everything can be pure. Any program needs to interact with the outside world. 
Side effects like saving and loading files, network calls, etc. are necessary.

It doesn’t even have to be all-or-nothing also. An almost-pure pure is almost as useful as 
a completely-pure one but the difference from an almost pure-function to a 
spaghetti-state abomination is immense.  Moving a function towards purity improves 
the code, even if it doesn’t reach full purity.  

A function that bumps an outside counter or checks an outside flag is not pure, but 
if that is its only detraction, it is still going to reap most of the benefits.
Avoiding the worst in a broader context is more important than achieving perfection in limited cases. 
If you think about the most toxic functions or systems you have had to deal with — 
the ones that you know have to be handled with tongs and a face shield — it is an almost 
sure bet that they have a complex web of state and assumptions that their behaviour relies on. 

Imposing some discipline in these areas, or at least fighting to prevent more code from 
turning into similar messes, is going to have more impact than tightening up some low level math functions.

The process of refactoring towards purity generally involves disentangling computation 
from the environment it operates in, which almost invariably means more parameter passing. 
This seems a bit curious – greater verbosity in programming languages is broadly reviled, 
and functional programming is often associated with code size reduction. 
You should be getting irritated if you have to pass a dozen parameters into a function; 
you may be able to refactor the code in a manner that reduces the parameter complexity.

Also a function can still be pure even if it calls impure functions, as long as the side 
effects don’t escape the outer function. For example programs can be considered pure functional 
units if they only deal with command line parameters instead of random file system state.

## Functional programming and classes
The “moving parts” in a program are the mutating states. Telling an object to change 
itself is lesson one in a basic object oriented programming book, and it is deeply 
ingrained in most programmers, but it is anti-functional behaviour.  

Clearly there is some value in the basic OOP idea of grouping functions with the data 
structures they operate on, but if you want to reap the benefits of functional 
programming in parts of your code, you have to back away from some object oriented behaviours in those areas.
Class methods are not pure by definition, because they mutate some or all of the potentially 
large set of state in the object. 
They are not thread safe, and the ability to incrementally poke and prod objects into 
unexpected states is indeed a significant source of bugs.
At the tactical programming level, you can often work with objects in a more functional manner, 
but it may require changing the interfaces a bit: to return output values instead of mutating 
the inner state of the object.  


## Immutability
Pure functions don’t mutate parameters and always return a new output. They always 
create new things and treat everything as immutable, as unchanging. 

Many great benefits result from this like thread safety, parallel computation and 
detecting changes by comparing objects by reference rather than checking all of the object state for change.
But of course, creating new things instead of mutating exiting ones has some performance penalties. 

### Performance Implications
In almost all cases, directly mutating blocks of memory is the speed-of-light optimal case, 
and avoiding this is spending some performance. Most of the time we trade performance for 
productivity all the time.
Programming with pure functions will involve more copying of data, and in some cases 
this clearly makes it the incorrect implementation strategy due to performance considerations. 
 As an extreme example, you can write a pure DrawTriangle() function that takes a 
 frame buffer as a parameter and returns a completely new frame buffer with the 
 triangle drawn into it as a result.  Don’t do that.
Returning everything by value is the natural functional programming style, but 
relying on compilers to always perform return value optimisation can be hazardous 
to performance, so passing reference parameter for output of complex data structures 
is often justifiable, but it has the unfortunate effect of preventing you from declaring 
the returned value as const to enforce single assignment.
There will be a strong urge in many cases to just update a value in a complex structure 
passed in rather than making a copy of it and returning the modified version, but doing
 so throws away the thread safety guarantee and should not be done lightly. 
  List generation is often a case where it is justified.  The pure functional way 
  to append something to a list is to return a completely new copy of the list with 
  the new element at the end, leaving the original list unchanged.  
  
Actual functional languages are implemented in ways that make this not as disastrous 
as it sounds, but if you do this with typical OOP containers you will die.

A significant mitigating factor is that performance today means parallel programming, 
which usually requires more copying and combining than in a single threaded environment even 
in the optimal performance case, so the penalty is smaller, while the complexity reduction 
and correctness benefits are correspondingly larger.  When you start thinking about running, 
say, all the characters in a game world in parallel, it starts sinking in that the object 
oriented approach of updating objects has some deep difficulties in parallel environments.  
Maybe if all of the object just referenced a read only version of the world state, and we 
copied over the updated version at the end of the frame…  Hey, wait a minute…

What to do:
* Review some complex functions or methods in your codebase and track down every 
bit of external state they can reach, and all possible modifications they can make. 
This makes great documentation to stick in a comment block, even if you don’t do anything with it. 
If the function can trigger, say, a screen update through your render system, 
you can just throw your hands up in the air and declare the set of all effects beyond human understanding.

* The next task you undertake, try from the beginning to think about it in terms of 
the real computation that is going on. Gather up your input, pass it to a pure function, 
then take the results and do something with it.

* As you are debugging code, make yourself more aware of the part mutating state and 
hidden parameters play in obscuring what is going on.

* Modify some of your utility object code to return new copies instead of self-mutating, 
and try throwing const in front of practically every non-iterator variable you use.

## Functional core, imperative shell
My strong believe is that every codebase must have a functional part. Ideally, 
every piece of code should have a functional core and an imperative shell:
Functional core handles state mutations by implementing the  complex and hairy logic that updates the state. 
Leveraging the power and simplicity of the pure functions and immutable data, 
this code is easily testable and easily made rock solid.

The Imperative shell, around the functional core, handles the binding with the 
rest of the world, it uses the data to perform side effects in the world: saving 
or loading data from file system or network, rendering on the screen, 
logging and any other operation with performance implications.


